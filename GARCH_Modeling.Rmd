---
title: "GARCH Modeling"
output:
  html_document:
    df_print: paged
---

## Load Required Libraries
```{r}
suppressPackageStartupMessages({
  library(quantmod) # for getSymbols
  library(zoo) # for na.omit
  library(ggplot2) # for plotting
  library(tseries) # for adf.test
  library(rugarch) # for GARCH modeling
  library(bayesGARCH) # for Bayesian GARCH
  library(stats) # for spectrum, acf, pacf
})
```

## Load and Plot 10-Year Treasury Yield Data
```{r} 
# "Market Yield on U.S. Treasury Securities at 10-Year Constant Maturity,
# Quoted on an Investment Basis"
getSymbols("DGS10", src = "FRED", from = "2010-01-01")
dgs10 <- na.omit(DGS10)  # Remove missing values (e.g., holidays)
plot(dgs10, main = "DGS10 - 10Y Treasury Constant Maturity Rate",
     col = "blue", ylab = "Yield (%)", xlab = "Date")
```

The yield curve clearly shows three regimes: post-GFC low rates, 
pandemic crash (~2020), and sharp rise post-2022 (inflation, Fed tightening).

## Preliminary Data Analysis
### Check for Stationarity
```{r}
# testing if its stationary
adf.test(dgs10, alternative = "stationary")
```

p-value is very large, so we have to accept H0 --> data is not stationary <br>
GARCH models require weakly stationary time series which can be tested with ADF

Compute daily changes, first difference to make it stationary.

```{r}
# diff computes the daily change. The first value is NA since there is no
# previous value to subtract from the first one, so we remove it.
dgs10_diff <- diff(dgs10)[-1]
dgs10_diff_sq <- dgs10_diff^2
colnames(dgs10_diff_sq) <- "SquaredDailyChange"
plot(dgs10_diff_sq, main = "Squared Daily Yield Changes in DGS10",
     col = "darkred", ylab = "∆ Yield (%)", xlab = "Date")
```

Major spikes around early 2020 (pandemic) and post-2022 (inflation uncertainty)

```{r}
# testing stationarity of the daily changes
adf.test(dgs10_diff_sq)
```

p-value is very low, so we can say that the data is weakly stationary now. 

### Frequency Spectrum of Daily Changes
```{r}
# Frequency spectrum of daily changes
spectrum(dgs10_diff_sq, method = "pgram",
         main = "Frequency Spectrum of DGS10 Squared Daily Changes",
         col = "darkgreen", ylab = "Power in dB", xlab = "Frequency",
         log = "dB")
```

```{r}
spectrum(dgs10_diff_sq, method = "pgram",
         main = "Frequency Spectrum of DGS10 Squared Daily Changes",
         col = "darkgreen", ylab = "Power", xlab = "Frequency",
         log = "no")
```

The spectrum is relatively flat with higher power at very low frequencies.
The spike near 0 indicates long-memory or persistent behavior in volatility.
The high power at low frequencies implies low-frequency (long-term) cycles dominate.

### ACF and PACF of Daily Changes
```{r}
acf(dgs10_diff_sq, main = "ACF of DGS10 Squared Daily Changes")
```

The ACF decays slowly and remains statistically significant for many lags.
Reinforces the presence of volatility clustering.
Suggests that past squared returns can predict future volatility to some extent.

```{r}
pacf(dgs10_diff_sq, main = "PACF of DGS10 Squared Daily Changes")
```

The PACF shows significant spikes up to lag ~7, especially lags 1–5.
This suggests that the squared daily changes exhibit short-term persistence or clustering.
There is conditional heteroskedasticity, supporting the use of ARCH/GARCH models for volatility modeling.

## GARCH Model Specification and Fitting
```{r}
# standard GARCH(1,1) model with Student-t innovations
# on the first difference of the 10-year Treasury yield series
spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  # mean model with no ARMA terms, just a constant mean
  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
  # Student-t distribution, assumed distribution of shocks/random errors
  distribution.model = "std"
)

# fit <- ugarchfit(spec, dgs10_diff_sq)
fit <- ugarchfit(spec, dgs10_diff)
show(fit)
```

## GARCH Model Evaluation Summary

- MLE converged because log-likelihood is finite
- all parameters have low p-values, so they are all important
- p-value is high for H0: $\mu$ = 0, which makes sense because we test the mean for the difference here
- $\alpha + \beta = 0.050617 + 0.941132 = 0.991749 < 1$, so it's still stationary but there is strong volatility persistence
- ARCH LM Test: p > 0.7 --> no remaining ARCH effects
- Stability Test: model parameters are stable
- Ljung-Box Test: no autocorrelation in residuals or squared residuals
- Sign Bias: Tests whether residual sign alone affects conditional variance
- Negative Sign Bias: Tests whether negative shocks increase volatility more than expected, p = 0.104 --> small assymetry
- Positive Sign Bias: Tests whether positive shocks increase volatility differently
- Joint Effect: F-test of all three biases combined




## GARCH with MLE, rolling prediction

```{r}
returns <- na.omit(diff(DGS10))[-1]
N <- length(returns)

# Use all but last 10 for training
train <- returns[1:(N - 10)]
test <- returns[(N - 9):N]

spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
  mean.model = list(armaOrder = c(0,0), include.mean = TRUE),
  distribution.model = "std"
)

# Rolling 1-day ahead forecast over last 10 points
roll <- ugarchroll(
  spec,
  data = returns,
  forecast.length = 10,
  refit.every = 1,
  refit.window = "moving",
  solver = "hybrid",
  calculate.VaR = FALSE
)

forecasted_sigma <- as.numeric(roll@forecast$density[, "Sigma"])

# Extract actual returns over the forecast period
realized_returns <- tail(returns, 10)
realized_vol <- abs(realized_returns)  # or use squared: realized_returns^2

# Prepare dataframe for plotting
comparison_df <- data.frame(
  Day = 1:10,
  ForecastedVol = forecasted_sigma,
  RealizedVol = realized_vol
)


# Plotting the results
ggplot(comparison_df, aes(x = Day)) +
  geom_line(aes(y = ForecastedVol), color = "blue", size = 1.2) +
  geom_line(aes(y = DGS10), color = "red", linetype = "dashed", size = 1.2) +
  labs(
    title = "Rolling 1-Day Ahead GARCH Volatility Forecast vs Realized Volatility",
    y = "Volatility (abs return or sigma)", x = "Forecast Day"
  ) +
  theme_minimal()
```

# Bayesian GARCH (Not working properly)

```{r}
fit_bayesian_garch <- function(r, control = list(n.chain = 1, l.chain = 10000), 
                               scale.factor = 1, silent = TRUE) {
  # Check package
  if (!requireNamespace("bayesGARCH", quietly = TRUE)) {
    stop("You need to install the 'bayesGARCH' package.")
  }
  
  # Scale input
  r_scaled <- as.numeric(r * scale.factor)
  
  # Fit model
  if (silent) {
    suppressMessages({
      fit <- bayesGARCH::bayesGARCH(r_scaled, control = control)
    })
  } else {
    fit <- bayesGARCH::bayesGARCH(r_scaled, control = control)
  }
  
  attr(fit, "scale.factor") <- scale.factor
  return(fit)
}




fit_bayes <- fit_bayesian_garch(returns, control = list(l.chain = 10))
summary(fit_bayes)
```



```{r}
posterior <- fit_bayes$chain1
colnames(posterior) <- c("alpha0", "alpha1", "beta", "nu")

mu     <- mean(returns)
#omega  <- mean(posterior$alpha0)
#alpha  <- mean(posterior$alpha1)
#beta   <- mean(posterior$beta)

posterior
```




