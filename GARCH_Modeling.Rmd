---
title: "GARCH Modeling"
output:
  html_document:
    df_print: paged
---


```{r}
# install.packages("quantmod")
# install.packages("zoo")
# install.packages("ggplot2")
# install.packages("tseries")
# install.packages("rugarch")
# install.packages("bayesGARCH")

library(quantmod)
library(zoo)
library(ggplot2)
library(tseries)
library(rugarch)
library(bayesGARCH)
```

```{r}
getSymbols("DGS10", src = "FRED", from = "2010-01-01")
dgs10 <- na.omit(DGS10)  # Remove missing values (e.g., holidays)
plot(dgs10, main = "DGS10 - 10Y Treasury Constant Maturity Rate", col = "blue")

# testing if its stationary
adf.test(dgs10)
```
p-value is very large, so we have to accept H0 --> data is not stationary <br>
GARCH models require weakly stationary time series which can be tested with ADF

```{r}
dgs10_diff <- diff(dgs10)[-1]  # Removes leading NA
colnames(dgs10_diff) <- "DailyChange"
plot(dgs10_diff, main = "Daily Yield Changes in DGS10", col = "darkred", ylab = "âˆ† Yield (%)")

# testing stationarity again 
adf.test(dgs10_diff) 
```

p-value is 0.01, so we can say that the data is weakly stationary now

```{r}
# sGARCH = Standard GARCH
spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
  mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
  distribution.model = "std"  # Student-t for heavy tails, optional
)

fit <- ugarchfit(spec, dgs10_diff)
show(fit)
```

## GARCH Model Evaluation Summary

- MLE converged because log-likelihood is finite
- all parameters have low p-values, so they are all important
- p-value is high for H0: $\mu$ = 0, which makes sense because we test the mean for the difference here
- $\alpha + \beta = 0.050617 + 0.941132 = 0.991749 < 1$, so it's still stationary but there is strong volatility persistence
- ARCH LM Test: p > 0.7 --> no remaining ARCH effects
- Stability Test: model parameters are stable
- Ljung-Box Test: no autocorrelation in residuals or squared residuals
- Sign Bias: Tests whether residual sign alone affects conditional variance
- Negative Sign Bias: Tests whether negative shocks increase volatility more than expected, p = 0.104 --> small assymetry
- Positive Sign Bias: Tests whether positive shocks increase volatility differently
- Joint Effect: F-test of all three biases combined




## GARCH with MLE, rolling prediction

```{r}
returns <- na.omit(diff(DGS10))[-1]
N <- length(returns)

# Use all but last 10 for training
train <- returns[1:(N - 10)]
test <- returns[(N - 9):N]



spec <- ugarchspec(
  variance.model = list(model = "sGARCH", garchOrder = c(1,1)),
  mean.model = list(armaOrder = c(0,0), include.mean = TRUE),
  distribution.model = "std"
)

# Rolling 1-day ahead forecast over last 10 points
roll <- ugarchroll(
  spec,
  data = returns,
  forecast.length = 10,
  refit.every = 1,
  refit.window = "moving",
  solver = "hybrid",
  calculate.VaR = FALSE
)



forecasted_sigma <- as.numeric(roll@forecast$density[, "Sigma"])

# Extract actual returns over the forecast period
realized_returns <- tail(returns, 10)
realized_vol <- abs(realized_returns)  # or use squared: realized_returns^2

# Prepare dataframe for plotting
comparison_df <- data.frame(
  Day = 1:10,
  ForecastedVol = forecasted_sigma,
  RealizedVol = realized_vol
)


# Plotting the results
ggplot(comparison_df, aes(x = Day)) +
  geom_line(aes(y = ForecastedVol), color = "blue", size = 1.2) +
  geom_line(aes(y = DGS10), color = "red", linetype = "dashed", size = 1.2) +
  labs(
    title = "Rolling 1-Day Ahead GARCH Volatility Forecast vs Realized Volatility",
    y = "Volatility (abs return or sigma)", x = "Forecast Day"
  ) +
  theme_minimal()
```

# Bayesian GARCH (Not working properly)

```{r}
fit_bayesian_garch <- function(r, control = list(n.chain = 1, l.chain = 10000), 
                               scale.factor = 1, silent = TRUE) {
  # Check package
  if (!requireNamespace("bayesGARCH", quietly = TRUE)) {
    stop("You need to install the 'bayesGARCH' package.")
  }
  
  # Scale input
  r_scaled <- as.numeric(r * scale.factor)
  
  # Fit model
  if (silent) {
    suppressMessages({
      fit <- bayesGARCH::bayesGARCH(r_scaled, control = control)
    })
  } else {
    fit <- bayesGARCH::bayesGARCH(r_scaled, control = control)
  }
  
  attr(fit, "scale.factor") <- scale.factor
  return(fit)
}




fit_bayes <- fit_bayesian_garch(returns, control = list(l.chain = 10))
summary(fit_bayes)
```



```{r}
posterior <- fit_bayes$chain1
colnames(posterior) <- c("alpha0", "alpha1", "beta", "nu")

mu     <- mean(returns)
#omega  <- mean(posterior$alpha0)
#alpha  <- mean(posterior$alpha1)
#beta   <- mean(posterior$beta)

posterior
```




